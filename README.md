# Тестовое задание на позицию C++ Intern
## Задание
Устройство хранения данных типа лента (Tape) предназначено для последовательной записи и
чтения данных. Считывающая/записывающая магнитная головка неподвижна во время чтения и
записи, а лента имеет возможность двигаться в обоих направлениях. Запись и чтение информации
возможны в ячейку ленты, на которой в данный момент находится магнитная головка.
Перемещения ленты – затратная по времени операция – лента не предназначена для
произвольного доступа.

Имеется входная лента длины N (где N – велико), содержащая элементы типа integer (2
32).
Имеется выходная лента такой же длины. Необходимо записать в выходную ленту
отсортированные по возрастанию элементы с входной ленты. Есть ограничение по использованию
оперативной памяти – не более M байт (M может быть < N, т.е. загрузить все данные с ленты в
оперативную память не получится). Для реализации алгоритма можно использовать разумное
количество временных лент, т.е. лент, на которых можно хранить какую-то временную
информацию, необходимую в процессе работы алгоритма.

Необходимо создать проект С++, компилируемый в консольное приложение, которое реализует
алгоритм сортировки данных с входной ленты на выходную. Необходимо сделать следующее:
- Определить интерфейс для работы с устройством типа лента.
- Написать класс, реализующий этот интерфейс и эмулирующий работу с лентой
посредством обычного файла. Должно быть возможно сконфигурировать (без
перекомпиляции – например, через внешний конфигурационный файл, который будет
прочитан на старте приложения) задержки по записи/чтению элемента с ленты, перемотки
ленты, и сдвига ленты на одну позицию.
- Файлы временных лент можно сохранять в директорию tmp.
- Написать класс, реализующий алгоритм сортировки данных с входной ленты на выходную.
- Консольное приложение должно принимать на вход имя входного и выходного файлов и
производить сортировку.
- Желательно написать юнит-тесты.
## Алгоритм сортировки
На вход мы имеем один буффер, с которым мы можем выполнять только следующие действия:
- Передвижение указателя назад и вперёд
- Чтение элемента, на который указывает указатель
- Запись элемента в позицию, на которую указывает указатель
- Удаление элемента, на который указывает указатель
- Также условно добавим возможность считать количество элементов в данном буфере для упрощения алгоритма.

У нас имеется ещё два вспомогательных буфера и один буфер, куда будем выводить отсортированный массив, и основная память, которую будем использовать только для сравнения двух чисел (т.е. её размер должен быть не меньше двух)

Алгоритм следующий:
1. Считываем два числа из входного буфера в основную память
2. Если в входном буфере только одно число, то кидаем его в выходной буфер и начинаем итерацию заново, только теперь входной буфер - буфер с большими числами.
3. Сравниваем эти два числа и кладём меньшее в один вспомогательный буфер, а другое в другой.
4. То же самое проделываем со всеми остальными числами (если в входном буфере останется одно число, то кидаем его в любой буфер)
5. После одной такой итерации у нас будет два заполненых буфера и один пустой.
6. Проделываем те же самые операции для буфера с меньшими числами, т.е. прогоняем алгоритм с п.1, только теперь входной буфер - буфер с меньшими числами.

Асимптотика данного решения O((n*log(n))^2)

## Пример ввода/вывода программы

#### input.txt
10

8 3 5 2 7 4 1 54 2 100
#### output.txt
1 2 2 3 4 5 7 8 54 100

ticks: 755